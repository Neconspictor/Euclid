	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	glfwWindowHint(GLFW_RESIZABLE, GL_TRUE);

	// only for macOS
	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
	
	GLFWwindow* window = glfwCreateWindow(800, 600, "LearnOpenGL", nullptr, nullptr);
	if (window == nullptr)
	{
		cerr << "Failed to create GLFW window!" << std::endl;
		glfwTerminate();
		return EXIT_FAILURE;
	}

	glfwMakeContextCurrent(window);

	glewExperimental = GL_TRUE;
	if (glewInit() != GLEW_OK)
	{
		cout << "Failed to init GLEW!" << std::endl;
		return EXIT_FAILURE;
	}

	int width, height;
	glfwGetFramebufferSize(window, &width, &height);
	glViewport(0, 0, width, height);

	glfwSetKeyCallback(window, Input::onKeyPressed);
	glfwSetWindowFocusCallback(window, Input::onWindowsFocus);
	glfwSetScrollCallback(window, Input::onScroll);

	// Enable blending
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	// init shaders
	PlaygroundShader shader("vertex.glsl", "fragment.glsl");
	shader.setTexture1("jpg.jpg");
	shader.setTexture2("png.png");
	SimpleLightShader simpleLightColorShader("vs_simpleLightColor.glsl", "fs_simpleLightColor.glsl");
	LampShader lampShader("vs_light.glsl", "fs_light.glsl");

	if (shader.loadingFailed())
	{
		cerr << "main(): Error: Shaders couldn't be loaded!" << endl;
		return EXIT_FAILURE;
	}

	if (simpleLightColorShader.loadingFailed())
	{
		cerr << "main(): Error: simpleLightColorShader couldn't be loaded!" << endl;
		return EXIT_FAILURE;
	}

	if (lampShader.loadingFailed())
	{
		cerr << "main(): Error: lampShader couldn't be loaded!" << endl;
		return EXIT_FAILURE;
	}

	/*TextureManager* textureManager = TextureManager::getInstance();
	GLuint texture = textureManager->loadImage("./_work/data/textures/jpg.jpg");
	cout << "Texture ID: " << texture << endl;
	GLuint texture2 = textureManager->loadImage("./_work/data/textures/png.png");
	cout << "Texture ID2: " << texture2 << endl;*/
	
	shared_ptr<Model> texturedCubeShared = ModelFactory::texturedCube();
	shared_ptr<Model> simpleLitCubeShared = ModelFactory::simpleLitCube();
	Model simpleLitCubeModel = *simpleLitCubeShared;
	Model textureedCubeModel = *texturedCubeShared;

	GLint nrAttributes;
	glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &nrAttributes);
	cout << "Maximum nr of vertex attributes supported: " << nrAttributes << endl;


	vec3 cubePositions[] = {
		vec3(0.0f,  0.0f,  0.0f),
		vec3(2.0f,  5.0f, -15.0f),
		vec3(-1.5f, -2.2f, -2.5f),
		vec3(-3.8f, -2.0f, -12.3f),
		vec3(2.4f, -0.4f, -3.5f),
		vec3(-1.7f,  3.0f, -7.5f),
		vec3(1.3f, -2.0f, -2.5f),
		vec3(1.5f,  2.0f, -2.5f),
		vec3(1.5f,  0.2f, -1.5f),
		vec3(-1.3f,  1.0f, -1.5f)
	};


	camera.setPosition(vec3(0.0f, 0.0f, 3.0f));
	camera.setLookDirection(vec3(0.0f, 0.0f, -1.0f));
	camera.setUpDirection(vec3(0.0f, 1.0f, 0.0f));
	input->addScrollListener(camera);

	GLfloat deltaTime = 0.0f;	// Time between current frame and last frame
	GLfloat lastTime = 0.0f;	// Time of the last frame


	glEnable(GL_DEPTH_TEST);


	while(!glfwWindowShouldClose(window))
	{
		//update frame time
		GLfloat currentTime = glfwGetTime();
		deltaTime = currentTime - lastTime;
		lastTime = currentTime;

		// handle events
		glfwPollEvents();
		handleWindowEvents(window);
		input->updateOnFrame(window, deltaTime);
		if (input->windowHasFocus())
		{
			MouseOffset offset = input->getFrameMouseOffset();
			camera.update(offset.xOffset, offset.yOffset);
		}

		updateMixValueByInput();
		doUserMovement(deltaTime);


		//rendering stuff
		glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);


		GLfloat radius = 10.0f;
		double time = glfwGetTime();
		GLfloat camX = sin(time) * radius;
		GLfloat camZ = cos(time) * radius;

		glBindVertexArray(0);

		mat4 view = lookAt(camera.getPosition(), camera.getPosition() + camera.getLookDirection(), camera.getUpDirection());

		vec3 lightPos(1.2f, 1.0f, 2.0f);
		mat4 model = mat4();
		model = translate(model, lightPos);
		model = scale(model, vec3(0.2f));
		mat4 projection;
		projection = perspective(radians(camera.getFOV()), (float)width / (float)height, 0.1f, 100.0f);
		mat4 trans = projection * view * model;
		lampShader.draw(simpleLitCubeModel, trans);

		simpleLightColorShader.setObjectColor(vec3(1.0f, 0.5f, 0.31f));

		Shader currentShader = simpleLightColorShader;

		for (int i = 0; i < 10; ++i)
		{
			mat4 model;
			mat4 rotation;
			mat4 rotation1;
			mat4 rotation2;
			mat4 translation;
			rotation1 = rotate(rotation1, radians(-55.0f), vec3(1.0f, 0.0f, 0.0f));
			vec4 up(0,1,0, 1);
			mat4 inverse = transpose(rotation1);
			up = inverse * up;
			rotation2 = rotate(rotation2, (float)radians(glfwGetTime()) * 50, vec3(up.x, up.y, up.z));
			translation = translate(translation, vec3(3.0f, 0.0f, 0.0f) + cubePositions[i]);
			rotation = rotation1 * rotation2;
			model = translation * rotation;
			mat4 projection;
			projection = perspective(radians(camera.getFOV()), (float)width / (float)height, 0.1f, 100.0f);
			mat4 trans = projection * view * model;
			//shader.setTextureMixValue(mixValue);
			simpleLightColorShader.draw(simpleLitCubeModel, trans);
		}

		glBindVertexArray(0);

		glfwSwapBuffers(window);
	}

	// Properly de-allocate all resources once they've outlived their purpose

	TextureManager::release();
	shader.release();
	lampShader.release();
	simpleLightColorShader.release();

	glfwTerminate();